Note: description generated by ChatGPT.
Code examples handwritten, if provided.

# ============================================================
# Class: Letterbox
# ============================================================
# Torch-backed letterbox resize (PIL -> PIL) with symmetric padding.
#
# Purpose:
#   - Resize an image to fit within a fixed canvas (W,H) while preserving aspect
#     ratio, then pad the remaining area with a constant RGB color.
#   - Uses PyTorch interpolate + pad for speed and easy CUDA offload.
#
# Args:
#   image_size (Tuple[int, int]):
#       Target canvas size as (W, H).
#   fill (Tuple[int, int, int]):
#       RGB padding color. Default: (114,114,114) like YOLO.
#   device (str):
#       Torch device for internal ops (e.g., "cpu", "cuda").
#
# Attributes:
#   tw (int): Target canvas width.
#   th (int): Target canvas height.
#   fill (Tuple[int,int,int]): Padding color used on each RGB channel.
#   device (torch.device): Device used for tensor operations.
#
# Public Methods:
#   __call__(img_pil: PIL.Image.Image) -> PIL.Image.Image
#       Perform letterbox resize on a PIL image and return a PIL image.
#       - Converts non-RGB images to RGB.
#       - Computes scale r = min(th/oh, tw/ow).
#       - Resizes with bilinear interpolation to (round(ow*r), round(oh*r)).
#       - Applies symmetric padding to reach (tw, th) using the provided RGB fill.
#       Returns:
#         PIL.Image.Image of size (tw, th).
#
#   __repr__() -> str
#       String representation showing size and fill color.
#
#   transform_image(pil_img: PIL.Image.Image) -> PIL.Image.Image
#       Alias to __call__; performs the letterbox transform.
#
#   transform_detections(
#       detections: List[MLTools.Detection],
#       orig_size: Tuple[int, int]
#   ) -> List[MLTools.Detection]
#       Adjust detections (in CXCYWH format) to the letterboxed coordinate space.
#       Assumes:
#         - Input detections have fields: cx, cy, w, h, rotation, class_id, confidence.
#         - orig_size is (W, H) of the pre-letterbox image.
#       Behavior:
#         - Applies the same scale r and symmetric padding (left/top) used in the image transform:
#             cx' = cx * r + left
#             cy' = cy * r + top
#             w'  = w  * r
#             h'  = h  * r
#         - Returns new Detection objects in the canvas space (tw, th).
#
# Notes:
#   - Resizing uses float32 tensors; outputs are clamped to [0,255] and cast to uint8.
#   - The three-channel fill is respected per-channel (supports non-equal RGB values).
#   - Rounding during resize may shift dimensions by Â±1 pixel depending on input size.
#
# Usage:
#   lb = Letterbox(image_size=(640, 640), fill=(114,114,114), device="cuda")
#   img_out = lb(img_in_pil)  # -> PIL.Image 640x640
#   dets_out = lb.transform_detections(dets_in, orig_size=(ow, oh))
